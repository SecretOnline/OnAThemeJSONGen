using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.IO;
using Newtonsoft.Json;

namespace OnATheme
{
    public class ModelExpon : Model
    {
        List<string> _randFaces = new List<string>();
        List<string> _randTextures = new List<string>();

        /// <summary>
        /// A model with permutations
        /// </summary>
        /// <param name="Name"></param>
        /// <param name="Parent"></param>
        /// <param name="RandTextures"></param>
        /// <param name="RandFaces"></param>
        /// <param name="ConstTextures"></param>
        /// <param name="XRotation"></param>
        /// <param name="YRotation"></param>
        public ModelExpon(string Name, string Parent, List<string> RandTextures, List<string> RandFaces, List<Texture> ConstTextures, bool[] XRotation, bool[] YRotation)
            : base(Name, Parent, ConstTextures, true, XRotation, YRotation)
        {
            _randTextures = RandTextures;
            _randFaces = RandFaces;
        }
        /// <summary>
        /// Total number of models that will be created by this class
        /// </summary>
        /// <returns></returns>
        private int NumModels()
        {
            return (int)Math.Pow(_randTextures.Count, _randFaces.Count);
        }
        public override void WriteModel()
        {
            int _model = 0;
            List<Texture> _modelTextures = new List<Texture>();

            foreach (Texture t in _textures)
            {
                _modelTextures.Add(t);
            }

            WriteExpon(_modelTextures, 0, ref _model);
            GC.Collect();
        }
        
        /// <summary>
        /// Create the model files for all of the possible combinations
        /// </summary>
        /// <param name="ModelTextures"></param>
        /// <param name="UnusedSides"></param>
        /// <param name="modelNo"></param>
        private void WriteExpon(List<Texture> ModelTextures, int Face, ref int modelNo)
        {
            // A recursive method with iteration. 
            // To quote someone in a fast elevator, "That escalated quickly."
            if (Face < _randFaces.Count)
            {
                for (int i = 0; i < _randTextures.Count; i++)
                {
                    ModelTextures.Add(new Texture(_randFaces[Face], _randTextures[i]));
                    WriteExpon(ModelTextures, Face + 1, ref modelNo);
                    ModelTextures.RemoveAt(ModelTextures.Count - 1); // Remove the last item (the one generated by this "for")
                }
            }
            else
            {
                // Write the model
                JsonWriter w = new JsonTextWriter(File.CreateText(@"OaT/assets/minecraft/models/block/" + _name + "_" + modelNo.ToString() + ".json"));
                w.Formatting = Formatting.Indented;

                w.WriteStartObject();
                w.WritePropertyName("parent");
                w.WriteValue(MODEL_PATH + _parent);
                w.WritePropertyName("textures");

                w.WriteStartObject();
                foreach (Texture t in ModelTextures)
                    t.WriteTextureJSON(w);
                w.WriteEndObject();

                w.WriteEndObject();

                w.Close();
                modelNo++;
            }
        }
        public override void WriteBlockstate(JsonWriter w)
        {
            // The loops and ifs are used to decide whether or not to write this variant as rotated.
            // Currently, thre is no way to specify different weights for each rotation (apart from manual editing)
            // To do so would be a pain to do. Hence, I'm not doing it. (right now, that is)
            for (int i = 0; i < 4; i++)
                if (_xRot[i])
                    for (int j = 0; j < 4; j++)
                        if (_yRot[j])
                        {
                            for (int k = 0; k < NumModels(); k++)
                            {
                                w.WriteStartObject();

                                w.WritePropertyName("model");
                                w.WriteValue(_name + "_" + k.ToString());

                                if (_weight != 1)
                                {
                                    w.WritePropertyName("weight");
                                    w.WriteValue(_weight);
                                }
                                if (i != 0) // Do not need to write if it's 0.
                                {
                                    w.WritePropertyName("x");
                                    w.WriteValue(i * 90);
                                }
                                if (j != 0) // Same as above.
                                {
                                    w.WritePropertyName("y");
                                    w.WriteValue(j * 90);
                                }
                                if (_uvLock)
                                {
                                    w.WritePropertyName("uvlock");
                                    w.WriteValue(true); // If this piece of code is executed, then it must be true.
                                }

                                w.WriteEndObject();
                            }
                        }
        }
    }
}
