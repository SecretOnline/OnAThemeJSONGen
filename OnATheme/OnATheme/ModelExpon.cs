using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.IO;
using Newtonsoft.Json;

namespace OnATheme
{
    class ModelExpon : Model
    {
        string[] _constTextures = new string[6]; // Constant textures (if not "")

        /// <summary>
        /// A model with permutations
        /// </summary>
        /// <param name="Name"></param>
        /// <param name="RandTextures"></param>
        public ModelExpon(string Name, List<string> RandTextures, string[] ConstTextures, bool[] XRotation, bool[] YRotation)
            : base(Name, "cube", new List<Texture>(), true, XRotation, YRotation)
        {
            if (ConstTextures.Length == 6)
                _constTextures = ConstTextures;

            foreach (string s in RandTextures)
                _textures.Add(new Texture("#", s));
        }

        /// <summary>
        /// Return the number of sides that don't have a constant texture
        /// </summary>
        /// <returns></returns>
        private int FreeSides()
        {
            int ret = 0;
            for (int i = 0; i < 6; i++)
                if (_constTextures[i] == "")
                    ret++;
            return ret;
        }
        /// <summary>
        /// Total number of models that will be created by this class
        /// </summary>
        /// <returns></returns>
        private int NumModels()
        {
            return _textures.Count ^ FreeSides(); // Note, this may end up being large. "May".
        }
        /// <summary>
        /// Returns the name of the side of the block, given an int from 0-5.
        /// </summary>
        /// <param name="index"></param>
        /// <returns></returns>
        public string Side(int index)
        {
            switch (index)
            {
                case 0:
                    return "down";
                case 1:
                    return "up";
                case 2:
                    return "north";
                case 3:
                    return "east";
                case 4:
                    return "south";
                case 5:
                    return "west";
                default:
                    throw new ArgumentException("Must be between 0 and 5");
            }
        }
        public override void WriteModel()
        {
            int _side = 0;
            WriteExpon(new List<Texture>(), 0, ref _side);
            GC.Collect();
        }
        
        /// <summary>
        /// Create the model files for all of the possible combinations
        /// </summary>
        /// <param name="ModelTextures"></param>
        /// <param name="UnusedSides"></param>
        /// <param name="modelNo"></param>
        private void WriteExpon(List<Texture> ModelTextures, int Side, ref int modelNo)
        {
            // A recursive method with iteration. 
            // To quote someone in a fast elevator, "That escalated quickly."
            if (Side < 6)
            {
                if (_constTextures[Side] == "")
                {
                    for (int i = 0; i < _textures.Count; i++)
                    {
                        ModelTextures.Add(new Texture(this.Side(Side), _textures[i].Name));
                        WriteExpon(ModelTextures, Side + 1, ref modelNo);
                        ModelTextures.RemoveAt(ModelTextures.Count - 1); // Remove the last item (the one generated by this "for")
                    }
                }
                else
                {
                    ModelTextures.Add(new Texture(this.Side(Side), _constTextures[Side]));
                    WriteExpon(ModelTextures, Side + 1, ref modelNo);
                    ModelTextures.RemoveAt(ModelTextures.Count - 1); // Remove the previous texture
                }
            }
            else
            {
                // Write the model
                JsonWriter w = new JsonTextWriter(File.CreateText(@"OaT/assets/minecraft/models/block/" + _name + "_" + modelNo.ToString() + ".json"));
                w.Formatting = Formatting.Indented;

                w.WriteStartObject();
                w.WritePropertyName("parent");
                w.WriteValue(MODEL_PATH + _parent);
                w.WritePropertyName("textures");

                w.WriteStartObject();
                foreach (Texture t in ModelTextures)
                    t.WriteTextureJSON(w);
                w.WriteEndObject();

                w.WriteEndObject();

                w.Close();
                modelNo++;
            }
        }
        public override void WriteBlockstate(JsonWriter w)
        {
            // The loops and ifs are usd to decide whether or not to write this variant as rotated.
            // Currently, thre is no way to specify different weights for each rotation (apart from manual editing)
            for (int i = 0; i < 4; i++)
                if (_xRot[i])
                    for (int j = 0; j < 4; j++)
                        if (_yRot[j])
                        {
                            for (int k = 0; k < NumModels(); k++)
                            {
                                w.WriteStartObject();

                                w.WritePropertyName("model");
                                w.WriteValue(_name + "_" + k.ToString());

                                if (_weight != 1)
                                {
                                    w.WritePropertyName("weight");
                                    w.WriteValue(_weight);
                                }
                                if (i != 0) // Do not need to write if it's 0.
                                {
                                    w.WritePropertyName("x");
                                    w.WriteValue(i * 90);
                                }
                                if (j != 0) // Same as above.
                                {
                                    w.WritePropertyName("y");
                                    w.WriteValue(j * 90);
                                }
                                if (_uvLock)
                                {
                                    w.WritePropertyName("uvlock");
                                    w.WriteValue(true); // If this piece of code is executed, then it must be true.
                                }

                                w.WriteEndObject();
                            }
                        }
        }
    }
}
